리스트, 스택, 큐
===
코딩 테스트를 위한 자료 구조와 알고리즘 with C++

- - -

## 연속된 자료 구조와 연결된 자료 구조
자료 구조는 크게 연속된 자료 구조(배열)와 연결된 자료 구조(연결리스트)로 구분할 수 있다.

+ 연속된 자료 구조
> Contiguous data structures. 모든 원소를 단일 memory chunk에 저장한다. 여기서 memory chunk는 하나의 연속된 메모리 덩어리를 의미한다.   
각각의 원소는 모두 같은 type을 사용한다. 그러므로 모든 원소는 같은 크기의 메모리를 사용하고, 이는 sizeof(type)으로 표시된다.   
첫 번째 원소의 메모리 주소를 시작 주소(BA, Base Address)라고 한다.   
따라서 i번째 원소에 접근하려면 BA + i * sizeof(type) 수식을 사용한다.

> 배열의 유형은 크게 정적 배열(Static array)과 동적 배열(Dynamic array) 두 가지로 나눌 수 있다.   
정적 배열은 Stack 메모리 영역에 할당되어, 선언된 블록이 끝나면, 즉 함수를 벗어날 때 자동으로 소멸(해제)된다.   
동적 배열은 Heap 영역에 할당되어, 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 결정할 수 있다(사용자가 직접 해제하기 전까지 유지).   
정적 배열은 int arr[size]; 형태로 선언한다.   
C에서 동적 배열은 int* arr = (int*)malloc(size * sizeof(int)); 형태로 선언한다.   
C++에서 동적 배열은 int* arr = new int[size]; 형태로 선언한다.

> 연속된 자료 구조에서, 각 원소는 서로 인접해 있기 때문에, 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 Cache로 가져온다.   
그러므로 다시 주변 원소에 접근할 때 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작하는데 이를 캐시 지역성(Cache locality)이라고 한다.   
따라서 배열은 캐시 지역성이 좋다고 말할 수 있다.   

+ 연결된 자료 구조
> Linked data structures. 노드(node)라고 하는 여러 개의 메모리 청크에 데이터를 저장하며, 이 경우 서로 다른 메모리 위치에 데이터가 저장된다.   
연결리스트의 기본 구조에서, 각각의 노드는 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가지고 있다.   
또한, 맨 마지막 노드에서는 다음 노드의 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가진다.   
연결리스트에서 특정 원소에 접근하려는 경우 리스트의 시작부분인 head 부분부터 시작하여 원하는 원소에 도달할 때까지 next 포인터를 따라 이동해야 한다.   
따라서 i번째 원소에 접근하려면 연결리스트 내부를 i번 이동하는 작업이 필요하고, 원소 접근 시간은 노드 개수에 비례하며 시간 복잡도로 표현하면 O(n)이다.

> 배열과 달리, 연결 리스트는 포인터를 이용하여 원소의 삽입 또는 삭제를 매우 빠르게 수행할 수 있다.   
삽입 시, 새로운 노드를 생성 -> 새로운 노드의 next 포인터가 다음 노드를 가리키게 만듦 -> 이전 노드의 next 포인터가 새로운 노드를 가리키게 만듦   
제거 시, 앞 노드의 next 포인터가 뒷 노드를 가리키게 만듦 -> 사이의 해당 노드를 해제

> 연결된 자료 구조에서, 각 원소들은 메모리에 연속적으로 저장되지 않으므로 캐시 지역성을 기대할 수 없다.

+ 비교
> 연속된 자료 구조와 연결된 자료 구조의 비교

|연속된 자료 구조|연결된 자료 구조|
|:---:|:---:|
|모든 데이터가 메모리에 연속적으로 저장|데이터는 노드에 저장되며, 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉각적 접근 가능|임의 원소에 접근하는 것은 선형 시간 복잡도를 가지며 느린 편|
|캐시 지역성 효과로 인해 모든 데이터 순회가 매우 빠름|캐시 지역성 효과가 없으므로 모든 데이터 순회가 느린 편|
|데이터 저장을 위해 정확하게 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|

> 다양한 연산에 대한 배열과 연결 리스트의 시간 복잡도

|파라미터|배열|연결리스트|
|:---:|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|

+ C 스타일 배열의 제약 사항
1. 메모리 할당과 해제를 수동으로 처리해야 함. 해제하지 않을 시 Memory leak 발생 가능(해당 메모리 영역 사용 불가능).
2. [] 연산자에서 배열 크기보다 큰 원소 참조를 검사할 수 없음. 잘못 사용 시 Segmentation fault 또는 메모리 손상 가능성 있음.
3. 배열 중첩 사용 시, 문법이 복잡하여 코드 이해 어려움.
4. 깊은 복사(Deep copy)가 기본으로 동작하지 않으므로 수동으로 구현해야 함.

- - -

## std::array
메모리를 자동으로 할당하고 해제하는 C++의 문법.   
원소의 타입과 배열 크기를 매개 변수로 사용하는 클래스 템플릿이다.

```
std::array<int, 10> arr1;   // 크기가 10인 int형 배열 선언
std::array<int, 4> arr2 = {1, 2, 3, 4};

std::cout << arr1[0] << std::endl;
for (int i = 0; i < arr2.size(); i++)
    std::cout << arr2[i] << " ";

// 출력값
// 1
// 1 2 3 4
```
> std::array는 C 스타일의 배열과 같은 방식으로 배열 원소에 접근할 수 있는 [] 연산자를 제공한다.   
배열 원소 인덱스를 지정할 경우, 빠른 동작을 위해서 전달된 인덱스 값이 배열의 크기보다 작은지를 검사하지는 않는다.   

```
std::array<int, 4> arr3 = {1, 2, 3, 4};

try {
    std::cout << arr3.at(3) << std::endl;   // 에러 아님
    std::cout << arr3.at(4) << std::endl;   // std::out_of_range 예외 발생
}
catch (const std::out_of_range& ex) {
    std::cerr << ex.what() << std::endl;    // std::cerr : 표준 오류 스트림
}
```
> 대신, std::array는 at(index) 형식의 함수도 함께 제공한다.   
이 함수는 인자로 전달된 index 값이 유효하지 않으면 std::out_of_range 예외(Exception)를 발생시킨다.   
그러므로 at(index)를 사용하면 [] 연산자보다는 좀 느리지만 예외를 적절하게 처리할 수 있다.

```
void print(std::array<int, 5>, arr) {
    for (auto element : arr)
        std::cout << element << ", ";
}

std::array<int, 5> arr = {1, 2, 3, 4, 5};
print(arr);
```
> std::array 객체를 다른 함수에 전달하는 방식은 기본 데이터 타입을 전달하는 것과 유사하다.   
값 또는 참조(Reference)로 전달할 수 있고, const를 함께 사용할 수도 있다.   
C 스타일 배열처럼 포인터 연산을 사용하거나 참조 또는 역참조 연산을 하지 않아도 된다.

```
template <size_t N>
void print(const std::array<int, N>& arr);
```
> 다양한 크기의 std::array 객체에 동작하는 범용적인 배열 출력 함수를 만들고자 할 경우, print()를 함수 템플릿으로 선언하고 배열 크기를 템플릿 매개변수로 전달한다.   
또한, 함수에 std::array 객체를 전달할 경우, 기본적으로 새로운 배열에 모든 원소가 복사되는 깊은 복사가 적용된다.   
이를 피하고 싶다면 참조 또는 const 참조를 사용한다.   

> std::array의 모든 원소는 범위 기반 for 반복문을 사용하여 접근할 수 있다. 이는 반복자를 사용하기 때문이다.   
std::array는 begin()과 end()라는 이름의 멤버 함수를 제공하며, 이 함수들은 각각 첫 번째 원소와 가장 마지막 원소의 다음 위치를 반환한다.   
즉, 범위 기반 for 반복문은 begin() 위치에서 시작해서 end() 위치에 도달하면 종료된다.

> std::array의 원소 접근 함수

|함수|설명|
|:---:|:---:|
|front()|배열의 첫 번째 원소에 대한 참조 반환|
|back()|배열의 마지막 원소에 대한 참조 반환|
|data()|배열 객체 내부에서 실제 데이터 메모리 버터를 가리키는 포인터 반환|

+ 연습문제 : C 스타일 배열을 대체하는 래퍼 클래스(wrapper class) 정의 방법 알아보기
1. 동적 크기 배열 구현하기   
학교에서 학생 정보를 관리하는 간단한 응용 프로그램 제작.   
한 반의 학생 수와 학생 정보는 프로그램 실행 시 입력받으며, 학생 데이터를 관리하기 위해 배열과 유사한 자료 구조를 사용해야 한다.   
이 배열은 다양한 크기를 지원해야 하며, 여러 반을 하나로 합치는 기능도 지원해야 한다.